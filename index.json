[{"content":"ğŸ› ï¸ ç¡¬ä»¶æ¶æ„ æ ¸å¿ƒæ¸…å• ä¸»æ§ï¼šESP32-S3 CAM å¼€å‘æ¿ éº¦å…‹é£ï¼šINMP441 å…¨å‘éº¦å…‹é£ åŠŸæ”¾/æ‰¬å£°å™¨ï¼šMAX98357A I2S åŠŸæ”¾ + 8Î© 1W å°å–‡å­ å…¶ä»–ï¼š3D æ‰“å°æ”¯æ¶ã€é”‚ç”µæ±  å¼•è„šå®šä¹‰ æ³¨æ„ï¼šç”±äº ESP32 å¼•è„šå¤ç”¨ï¼ˆä¾‹å¦‚ GPIO 42 å’Œ GNDï¼‰ï¼Œåœ¨è®¾è®¡éªŒè¯é˜¶æ®µå»ºè®®ä½¿ç”¨é¢åŒ…æ¿æ‰©å±•å¼•è„šï¼ŒéªŒè¯æ— è¯¯åè¿›è¡Œç„Šæ¥é›†æˆã€‚\n[ ESP32-S3 å¼€å‘æ¿ ] | +---- 3.3V ---------\u0026gt; [INMP441 VDD] +---- GND ----------+-\u0026gt; [INMP441 GND] \u0026amp; [L/R] | | +---- 5V (VBUS) ----+-\u0026gt; [MAX98357 Vin] | | +---- GND ----------+-\u0026gt; [MAX98357 GND] | [æ•°æ®çº¿] GPIO 39 \u0026lt;---------------------- [INMP441 SD] GPIO 40 ----------------------\u0026gt; [MAX98357 DIN] [æ—¶é’Ÿçº¿ - å…³é”®ï¼è¿™é‡Œè¦åˆ†å‰] GPIO 41 ------------------+---\u0026gt; [INMP441 SCK] | +---\u0026gt; [MAX98357 BCLK] GPIO 42 ------------------+---\u0026gt; [INMP441 WS] | +---\u0026gt; [MAX98357 LRC] é©±åŠ¨ä»£ç  ä»£ç å— compile.ino\n#include \u0026#34;esp_camera.h\u0026#34; #include \u0026lt;WiFi.h\u0026gt; #include \u0026lt;ArduinoWebsockets.h\u0026gt; #include \u0026lt;Adafruit_NeoPixel.h\u0026gt; #include \u0026lt;driver/i2s.h\u0026gt; using namespace websockets; // ================= é…ç½®åŒº ================= const char* ssid = \u0026#34;502\u0026#34;; const char* password = \u0026#34;sxz20220121\u0026#34;; const char* websocket_server_host = \u0026#34;192.168.1.101\u0026#34;; const uint16_t websocket_server_port = 8888; // ================= RGB ç¯é…ç½® ================= #define RGB_BUILTIN_PIN 48 Adafruit_NeoPixel strip(1, RGB_BUILTIN_PIN, NEO_GRB + NEO_KHZ800); // ================= æ‘„åƒå¤´å¼•è„š (ä¿æŒä¸å˜) ================= #define PWDN_GPIO_NUM -1 #define RESET_GPIO_NUM -1 #define XCLK_GPIO_NUM 15 #define SIOD_GPIO_NUM 4 #define SIOC_GPIO_NUM 5 #define Y9_GPIO_NUM 16 #define Y8_GPIO_NUM 17 #define Y7_GPIO_NUM 18 #define Y6_GPIO_NUM 12 #define Y5_GPIO_NUM 10 #define Y4_GPIO_NUM 8 #define Y3_GPIO_NUM 9 #define Y2_GPIO_NUM 11 #define VSYNC_GPIO_NUM 6 #define HREF_GPIO_NUM 7 #define PCLK_GPIO_NUM 13 // ================= éŸ³é¢‘ I2S å¼•è„š (ä¿æŒä¸å˜) ================= #define I2S_WS 42 #define I2S_SD 40 // åŠŸæ”¾è¾“å…¥ (DIN) #define I2S_SD_IN 39 // éº¦å…‹é£è¾“å‡º (SD) #define I2S_SCK 41 #define I2S_PORT I2S_NUM_0 #define SAMPLE_RATE 16000 WebsocketsClient client; // ================= å…¨å±€å˜é‡ ================= // éŸ³é¢‘ç¼“å†²åŒºï¼šå¢åŠ åˆ° 1024 å­—èŠ‚ä»¥å‡å°‘å‘é€é¢‘ç‡ï¼Œæé«˜ç½‘ç»œæ•ˆç‡ const int i2s_buffer_len = 1024; int16_t sBuffer[i2s_buffer_len]; // æ•°æ®åŒ…å¤´å®šä¹‰ const uint8_t HEADER_VIDEO = 0x01; const uint8_t HEADER_AUDIO = 0x02; // --- I2S åˆå§‹åŒ–å‡½æ•° --- void setupAudio() { i2s_config_t i2s_config = { .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX), .sample_rate = SAMPLE_RATE, .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT, .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT, .communication_format = I2S_COMM_FORMAT_STAND_I2S, .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1, .dma_buf_count = 8, .dma_buf_len = 64, .use_apll = false, .tx_desc_auto_clear = true, .fixed_mclk = 0 }; i2s_pin_config_t pin_config = { .bck_io_num = I2S_SCK, .ws_io_num = I2S_WS, .data_out_num = I2S_SD, .data_in_num = I2S_SD_IN }; if (i2s_driver_install(I2S_PORT, \u0026amp;i2s_config, 0, NULL) != ESP_OK) return; if (i2s_set_pin(I2S_PORT, \u0026amp;pin_config) != ESP_OK) return; i2s_zero_dma_buffer(I2S_PORT); } // --- WebSocket æ”¶åˆ°æ¶ˆæ¯å›è°ƒ (ç”¨äºæ’­æ”¾æœåŠ¡å™¨å‘æ¥çš„éŸ³é¢‘) --- void onMessageCallback(WebsocketsMessage message) { if (message.isBinary()) { // å‡è®¾æœåŠ¡å™¨ç›´æ¥å‘å› PCM éŸ³é¢‘æ•°æ® const char* data = message.c_str(); size_t len = message.length(); size_t bytesOut; // å°†æ”¶åˆ°çš„æ•°æ®å†™å…¥ I2S (æ‰¬å£°å™¨) i2s_write(I2S_PORT, data, len, \u0026amp;bytesOut, 0); } } void setup() { Serial.begin(115200); // 1. å…³ç¯ strip.begin(); strip.setBrightness(0); strip.setPixelColor(0, strip.Color(0, 0, 0)); strip.show(); // 2. æ‘„åƒå¤´åˆå§‹åŒ– camera_config_t config; config.ledc_channel = LEDC_CHANNEL_0; config.ledc_timer = LEDC_TIMER_0; config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM; config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM; config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM; config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM; config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM; config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM; config.pin_sccb_sda = SIOD_GPIO_NUM; config.pin_sccb_scl = SIOC_GPIO_NUM; config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM; config.xclk_freq_hz = 10000000; config.frame_size = FRAMESIZE_QVGA; config.pixel_format = PIXFORMAT_JPEG; config.grab_mode = CAMERA_GRAB_LATEST; config.fb_location = CAMERA_FB_IN_PSRAM; config.jpeg_quality = 30; config.fb_count = 2; if (esp_camera_init(\u0026amp;config) != ESP_OK) { Serial.println(\u0026#34;Cam Fail\u0026#34;); return; } // 3. åˆå§‹åŒ–éŸ³é¢‘ setupAudio(); // 4. WiFi WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\u0026#34;.\u0026#34;); } // æ³¨å†Œå›è°ƒæ¥æ”¶æœåŠ¡å™¨éŸ³é¢‘ client.onMessage(onMessageCallback); client.connect(websocket_server_host, websocket_server_port, \u0026#34;/\u0026#34;); } void loop() { // ä¿æŒ WebSocket æ´»è·ƒ if (client.available()) { client.poll(); } else { delay(500); client.connect(websocket_server_host, websocket_server_port, \u0026#34;/\u0026#34;); return; } // ================= ä»»åŠ¡ A: å‘é€éŸ³é¢‘ (é«˜ä¼˜å…ˆçº§) ================= size_t bytesIn = 0; // å°è¯•éé˜»å¡è¯»å–éº¦å…‹é£æ•°æ® esp_err_t result = i2s_read(I2S_PORT, \u0026amp;sBuffer, i2s_buffer_len * sizeof(int16_t), \u0026amp;bytesIn, 0); if (result == ESP_OK \u0026amp;\u0026amp; bytesIn \u0026gt; 0) { // åˆ›å»ºæ•°æ®åŒ…: [1å­—èŠ‚ç±»å‹å¤´] + [PCMæ•°æ®] // åŠ¨æ€åˆ†é…å†…å­˜ä»¥åˆå¹¶å¤´å’Œæ•°æ® (ESP32æœ‰è¶³å¤ŸRAMå¤„ç†è¿™ä¸ªå°åŒ…) uint8_t* payload = new uint8_t[bytesIn + 1]; payload[0] = HEADER_AUDIO; // æ ‡è®°ä¸ºéŸ³é¢‘ memcpy(payload + 1, sBuffer, bytesIn); client.sendBinary((const char*)payload, bytesIn + 1); delete[] payload; // è®°å¾—é‡Šæ”¾å†…å­˜ } // ================= ä»»åŠ¡ B: å‘é€è§†é¢‘ (ä½ä¼˜å…ˆçº§) ================= static unsigned long lastVideoTime = 0; // æ§åˆ¶å¸§ç‡ä¸º 10FPS (100msé—´éš”)ï¼Œç»™éŸ³é¢‘ç•™å‡ºå¸¦å®½ if (millis() - lastVideoTime \u0026gt; 100) { camera_fb_t * fb = esp_camera_fb_get(); if (fb) { // åˆ›å»ºæ•°æ®åŒ…: [1å­—èŠ‚ç±»å‹å¤´] + [JPEGæ•°æ®] // æ³¨æ„ï¼šè§†é¢‘æ•°æ®è¾ƒå¤§ï¼Œé¢‘ç¹ malloc å¯èƒ½ä¼šå¯¼è‡´ç¢ç‰‡ï¼Œä½†ArduinoWebsocketsä¸æ”¯æŒåˆ†æ®µå‘é€ uint8_t* videoPayload = new uint8_t[fb-\u0026gt;len + 1]; videoPayload[0] = HEADER_VIDEO; // æ ‡è®°ä¸ºè§†é¢‘ memcpy(videoPayload + 1, fb-\u0026gt;buf, fb-\u0026gt;len); client.sendBinary((const char*)videoPayload, fb-\u0026gt;len + 1); delete[] videoPayload; esp_camera_fb_return(fb); } lastVideoTime = millis(); } } ğŸ“– ä½¿ç”¨è¯´æ˜ 1. åˆ›å»ºå·¥ç¨‹ æ‰“å¼€ Arduino IDEï¼Œç‚¹å‡»å·¦ä¸Šè§’èœå•æ  File -\u0026gt; New Sketchï¼Œå°†æ–‡ä»¶å‘½åä¸º compile.inoï¼Œå¹¶å°†ä¸Šè¿°é©±åŠ¨ä»£ç å®Œæ•´å¤åˆ¶è¿›å»ã€‚\n2. ç¡¬ä»¶è¿æ¥ ç‚¹å‡»èœå•æ  Toolsï¼Œåœ¨ Board é€‰é¡¹ä¸­é€‰æ‹© esp32 -\u0026gt; ESP32S3 Dev Moduleã€‚ æ­¤æ—¶å°†å•ç‰‡æœºé€šè¿‡ USB æ’å…¥ç”µè„‘ï¼Œç¡®ä¿ Port é€‰é¡¹ä¸­æ˜¾ç¤ºäº†å¯¹åº”çš„ç«¯å£å·ï¼ˆä¾‹å¦‚ COM4 æˆ– /dev/ttyUSB0ï¼‰ã€‚\n3. âš™ï¸ å…³é”®é…ç½® (Tools èœå•) è¯·åŠ¡å¿…æŒ‰ç…§ä»¥ä¸‹å‚æ•°ä¸¥æ ¼è®¾ç½®ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´ä¸²å£æ— è¾“å‡ºæˆ–æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥ï¼š\nUSB CDC On Boot: Enabled (å…³é”®ï¼å¿…é¡»å¼€å¯) PSRAM: OPI PSRAM (è‹¥æ— æ•ˆå¯å°è¯• QSPI) Flash Mode: QIO 80MHz Flash Size: 4MB (64Mb) Partition Scheme: Huge APP (3MB No OTA/1MB SPIFFS) CPU Frequency: 240MHz (WiFi) å…¶ä»–é€‰é¡¹ä¿æŒé»˜è®¤å³å¯ 4. ğŸ“¦ ç¯å¢ƒé…ç½® (Library Manager) ç‚¹å‡»å·¦ä¾§è¾¹æ çš„â€œå›¾ä¹¦çŠ¶â€å›¾æ ‡ï¼ˆLibrary Managerï¼‰ï¼Œæœç´¢å¹¶å®‰è£…ä»¥ä¸‹åº“ï¼š\nArduinoWebsockets (by Gil Maimon) æ³¨æ„ï¼šè¯·è®¤å‡†ä½œè€… Gil Maimonã€‚ä¸è¦å®‰è£…å…¶ä»– WebSocket åº“ï¼Œå¦åˆ™ä»£ç ä¸­çš„ using namespace websockets; ä¼šæŠ¥é”™ã€‚ Adafruit NeoPixel (by Adafruit) ç”¨äºæ§åˆ¶æ¿è½½ RGB ç¯ã€‚ å…³äº ESP32 å¼€å‘æ¿ç‰ˆæœ¬ï¼š å»ºè®®åœ¨ Board Manager ä¸­å°† ESP32 åŒ…ç‰ˆæœ¬å›ºå®šåœ¨ 2.0.17ã€‚\n3.0.x ç‰ˆæœ¬ API æœ‰é‡å¤§å˜åŠ¨ï¼Œå¯èƒ½ä¼šæç¤º i2s_driver_install æŠ¥é”™ã€‚ å¦‚æœé‡åˆ°ç¼–è¯‘é”™è¯¯ï¼Œè¯·å›é€€åˆ° 2.0.17 ç‰ˆæœ¬ã€‚ 5. âš¡ çƒ§å½•ä¸è°ƒè¯• ç‚¹å‡»å·¦ä¸Šè§’ Upload (â¡ï¸) æŒ‰é’®å¼€å§‹çƒ§å½•ã€‚ çƒ§å½•å®Œæˆåï¼Œæ‰“å¼€å³ä¸Šè§’çš„ Serial Monitor (ä¸²å£ç›‘è§†å™¨)ï¼Œå°†æ³¢ç‰¹ç‡è®¾ç½®ä¸º 115200ã€‚\n6. ğŸ”§ å¸¸è§é—®é¢˜è‡ªæŸ¥ (FAQ) Q: ä¸²å£ç›‘è§†å™¨ä»€ä¹ˆéƒ½ä¸æ˜¾ç¤ºï¼Ÿ\nA: æ£€æŸ¥é…ç½®ä¸­ \u0026ldquo;USB CDC On Boot\u0026rdquo; æ˜¯å¦å·²è®¾ä¸º Enabledã€‚ä¸Šä¼ å®Œæˆåï¼Œå°è¯•æŒ‰ä¸€ä¸‹æ¿å­ä¸Šçš„ RST (å¤ä½) é”®ã€‚ Q: æŠ¥é”™ \u0026ldquo;Camera Init Failed\u0026rdquo;ï¼Ÿ\nA: é€šå¸¸æ˜¯ PSRAM è®¾ç½®é—®é¢˜ã€‚è¯·æ£€æŸ¥ PSRAM é€‰é¡¹æ˜¯å¦ä¸º OPI PSRAMã€‚å¦‚æœä¸è¡Œï¼Œå°è¯•æ”¹ä¸º QSPI PSRAMï¼ˆå–å†³äºç¡¬ä»¶æ‰¹æ¬¡ï¼‰ã€‚ Q: ä¸€ç›´è¿æ¥ä¸ä¸Š WiFiï¼Ÿ\nA: ESP32 ä»…æ”¯æŒ 2.4GHz WiFiï¼Œä¸æ”¯æŒ 5G é¢‘æ®µã€‚è¯·ç¡®è®¤æ‚¨çš„çƒ­ç‚¹è®¾ç½®ã€‚ Q: çƒ§å½•æˆåŠŸä½†åŠŸèƒ½å¼‚å¸¸ï¼Ÿ\nA: é…ç½®å¥½åï¼Œè§‚å¯Ÿä¸²å£ç›‘è§†å™¨ï¼Œæ­£å¸¸æƒ…å†µä¸‹åº”èƒ½çœ‹åˆ° \u0026ldquo;éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ\u0026rdquo; å’Œ \u0026ldquo;WiFi Connected\u0026rdquo; çš„æç¤ºã€‚ 7. ğŸ æŠ¥é”™è§£å†³ å¦‚æœç¼–è¯‘æˆ–è¿è¡Œè¿‡ç¨‹ä¸­å‡ºç°å…¶ä»–æŠ¥é”™ï¼Œè¯·ç›´æ¥å¤åˆ¶ Output æ ä¸‹æ–¹çš„çº¢è‰²æŠ¥é”™ä¿¡æ¯å‘é€ç»™ AIï¼Œé€šå¸¸èƒ½å¿«é€Ÿå®šä½é—®é¢˜ã€‚\n8. ğŸ“ ç¡¬ä»¶å¤‡æ³¨ æŒ‰é”®ï¼šæ¿å­ä¸Šæœ‰ä¸¤ä¸ªæŒ‰é”®ï¼Œé€šå¸¸åªå…³æ³¨ RST (å¤ä½/é‡å¯) é”®ï¼Œå¦ä¸€ä¸ª BOOT é”®åœ¨è‡ªåŠ¨çƒ§å½•å¤±è´¥æ—¶æ‰éœ€è¦ç”¨åˆ°ã€‚ æ¥å£ï¼šæ¿å­æœ‰ä¸¤ä¸ª USB æ¥å£ï¼Œè¯·æ’ å³è¾¹ (æ ‡è®°ä¸º USB) çš„æ¥å£è¿›è¡Œçƒ§å½•å’Œä¾›ç”µã€‚ æœåŠ¡ç«¯ä»£ç ï¼ˆå‚è€ƒï¼‰ ä»£ç å— import asyncio import websockets import cv2 import numpy as np import pyaudio # ================= é…ç½®åŒº ================= HOST = \u0026#34;0.0.0.0\u0026#34; PORT = 8888 # ================= åè®®å®šä¹‰ (ä¸ ESP32 ä¿æŒä¸€è‡´) ================= HEADER_VIDEO = 0x01 HEADER_AUDIO = 0x02 # ================= éŸ³é¢‘é…ç½® ================= # ESP32 å‘é€çš„æ˜¯: 16000Hz, 16-bit (2 bytes), å•å£°é“ FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK = 1024 async def stream_handler(websocket): print(f\u0026#34;[Server] å®¢æˆ·ç«¯å·²è¿æ¥: {websocket.remote_address}\u0026#34;) # 1. åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å¯¹è±¡ p = pyaudio.PyAudio() # æ‰“å¼€éŸ³é¢‘æµ (Output æ¨¡å¼) stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, output=True, frames_per_buffer=CHUNK) print(\u0026#34;[Server] éŸ³é¢‘æµå·²åˆå§‹åŒ–ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®...\u0026#34;) try: async for message in websocket: # 2. æ¥æ”¶äºŒè¿›åˆ¶æ•°æ® if isinstance(message, bytes): if len(message) \u0026lt; 2: continue # æ•°æ®å¤ªçŸ­ï¼Œå¿½ç•¥ # === æ ¸å¿ƒé€»è¾‘: è§£æåŒ…å¤´ === header = message[0] # è·å–ç¬¬1ä¸ªå­—èŠ‚ (åè®®å¤´) payload = message[1:] # è·å–å‰©ä½™æ•°æ® (æœ‰æ•ˆè´Ÿè½½) # --- æƒ…å†µ A: è§†é¢‘æ•°æ® --- if header == HEADER_VIDEO: nparr = np.frombuffer(payload, np.uint8) frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR) if frame is not None: # å¯é€‰: ç¿»è½¬ä¸€ä¸‹ï¼Œé˜²æ­¢è‡ªæ‹é•œåƒ # frame = cv2.flip(frame, 1) cv2.imshow(\u0026#34;ESP32-S3 Live Stream\u0026#34;, frame) if cv2.waitKey(1) \u0026amp; 0xFF == ord(\u0026#39;q\u0026#39;): break # --- æƒ…å†µ B: éŸ³é¢‘æ•°æ® --- elif header == HEADER_AUDIO: # ç›´æ¥å†™å…¥å£°å¡æ’­æ”¾ # æ³¨æ„: ä¸ºäº†ä¸é˜»å¡ EventLoopï¼Œè¿™é‡Œçš„æ•°æ®åŒ…æœ€å¥½ä¸è¦å¤ªå¤§ stream.write(payload) # print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) # æ‰“å°ä¸ªç‚¹è¡¨ç¤ºæ”¶åˆ°éŸ³é¢‘ else: print(f\u0026#34;[Text] æ”¶åˆ°æ–‡æœ¬: {message}\u0026#34;) except websockets.exceptions.ConnectionClosed: print(\u0026#34;\\n[Server] å®¢æˆ·ç«¯æ–­å¼€è¿æ¥\u0026#34;) except Exception as e: print(f\u0026#34;\\n[Error] {e}\u0026#34;) finally: # æ¸…ç†èµ„æº print(\u0026#34;[Server] æ¸…ç†èµ„æº...\u0026#34;) stream.stop_stream() stream.close() p.terminate() cv2.destroyAllWindows() async def main(): print(f\u0026#34;=== AI Glass Server (Video + Audio) ===\u0026#34;) print(f\u0026#34;ç›‘å¬åœ°å€: ws://{HOST}:{PORT}\u0026#34;) async with websockets.serve(stream_handler, HOST, PORT): await asyncio.Future() # æ°¸ä¹…è¿è¡Œ if __name__ == \u0026#34;__main__\u0026#34;: try: asyncio.run(main()) except KeyboardInterrupt: print(\u0026#34;åœæ­¢æœåŠ¡\u0026#34;) ğŸ“ æµ‹è¯•ä¸è¯´æ˜ æ¨æµæ€§èƒ½å®æµ‹ï¼š ç»å±€åŸŸç½‘ç¯å¢ƒæµ‹è¯•ï¼ŒESP32 èƒ½å¤Ÿç¨³å®šåœ°å°†è§†é¢‘æµï¼ˆMJPEGï¼‰å’ŒéŸ³é¢‘æµï¼ˆPCMï¼‰ä¼ è¾“è‡³ç”µè„‘ç«¯ï¼Œå»¶è¿Ÿè¾ƒä½ä¸”æ— æ˜æ˜¾å¡é¡¿ï¼Œæ»¡è¶³å®æ—¶è¯†åˆ«çš„åŸºç¡€è¦æ±‚ã€‚\nå…³äºè¯­éŸ³è¾“å‡ºï¼š ä»£ç ä¸­å·²é¢„ç•™äº†éŸ³é¢‘ä¸‹å‘é€»è¾‘ã€‚è‹¥éœ€æµ‹è¯•åŒå‘å¯¹è®²æˆ– TTS æ’­æŠ¥ï¼Œè¯·ç¡®ä¿åœ¨ç¡¬ä»¶ç«¯å·²æ­£ç¡®è¿æ¥ MAX98357A åŠŸæ”¾æ¨¡å—ä¸ 8Î© å–‡å­ï¼Œç†è®ºä¸ŠæœåŠ¡ç«¯å‘é€ PCM æ•°æ®å³å¯ç›´æ¥æ’­æ”¾ã€‚\nâš ï¸ æ³¨æ„ï¼š æœ¬æ–‡æä¾›çš„æœåŠ¡ç«¯ä»£ç ï¼ˆPythonï¼‰ä¸»è¦ç”¨äºéªŒè¯ç¡¬ä»¶é€šè·¯ä¸åè®®å¯è¡Œæ€§ã€‚\nğŸš€ æ€»ç»“ä¸ä¸‹ä¸€æ­¥ è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†â€œAI è§†éšœçœ¼é•œâ€çš„ èº¯ä½“æ„å»ºï¼š\nç¡¬ä»¶å±‚ï¼šåŸºäº ESP32-S3 æ­å»ºäº†å…·å¤‡è§†è§‰ï¼ˆæ‘„åƒå¤´ï¼‰å’Œå¬è§‰ï¼ˆéº¦å…‹é£/å–‡å­ï¼‰çš„ç‰©ç†ç»ˆç«¯ã€‚ é©±åŠ¨å±‚ï¼šå®ç°äº† I2S éŸ³é¢‘é‡‡æ ·ä¸ Camera è§†é¢‘æµçš„åŒæ­¥è·å–ã€‚ ä¼ è¾“å±‚ï¼šæ‰“é€šäº†è®¾å¤‡åˆ°æœåŠ¡å™¨çš„ WebSocket é«˜é€Ÿæ•°æ®é€šè·¯ã€‚ ä½†æ˜¯ï¼Œç°åœ¨çš„çœ¼é•œè¿˜åªæ˜¯ä¸€ä¸ªâ€œè¿œç¨‹æ‘„åƒå¤´â€ï¼Œå®ƒè¿˜æ²¡æœ‰â€œå¤§è„‘â€ã€‚\nåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†è¿›å…¥æ ¸å¿ƒçš„ AI ç®—æ³•ç¯‡ï¼Œè®²è§£å¦‚ä½•åœ¨æœåŠ¡ç«¯æ¥å…¥ï¼š\nYOLOv8ï¼šè®©çœ¼é•œâ€œçœ‹æ‡‚â€é¢å‰æ˜¯çº¢ç»¿ç¯ã€æ–‘é©¬çº¿è¿˜æ˜¯å°é˜¶ã€‚ å¤šæ¨¡æ€ LLMï¼šè®©çœ¼é•œèƒ½å¤Ÿç”¨è‡ªç„¶è¯­è¨€æè¿°å‘¨å›´çš„ç¯å¢ƒï¼ˆä¾‹å¦‚ï¼šâ€œå‰æ–¹äº”ç±³æœ‰ä¸€è¾†å…±äº«å•è½¦æŒ¡è·¯ï¼Œè¯·å‘å·¦ç»•è¡Œâ€ï¼‰ã€‚ æ•¬è¯·æœŸå¾…ï¼\n","permalink":"https://wave-cb.github.io/projects/aiglass_%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/","summary":"æœ¬æ–‡ä»ç¡¬ä»¶æ¶æ„ã€é©±åŠ¨ä»£ç ã€æœåŠ¡ç«¯ä¸‰ä¸ªéƒ¨åˆ†è¿›è¡Œè®²è§£ï¼Œè¯¦ç»†ä»‹ç»äº†åŸºäº ESP32-S3 çš„éŸ³è§†é¢‘æµä¼ è¾“å®ç°ã€‚","title":"ğŸ‘“ AIè§†éšœçœ¼é•œçš„ç¡¬ä»¶è®¾è®¡"},{"content":"ğŸš€ é¡¹ç›®èƒŒæ™¯ï¼šè¶…è¶Šâ€œèŠå¤©â€çš„è¡ŒåŠ¨è¾…åŠ© ä¸ºä»€ä¹ˆè¦åšè¿™ä¸ªé¡¹ç›®ï¼Ÿ\nç›®å‰å¸‚é¢ä¸Šçš„ AI çœ¼é•œå¤§å¤šåœç•™åœ¨â€œGPT å¯¹è¯â€å±‚é¢ï¼Œç¼ºä¹å¯¹ç‰©ç†ä¸–ç•Œçš„æ„ŸçŸ¥èƒ½åŠ›ã€‚æœ¬é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€ä¸ªçœŸæ­£çš„è§†éšœäººå£«è¡ŒåŠ¨è¾…åŠ©ç³»ç»Ÿ ã€‚\nå®ƒä¸ä»…èƒ½â€œçœ‹â€åˆ°ä¸–ç•Œï¼Œè¿˜èƒ½ç†è§£å¤æ‚çš„ç¯å¢ƒâ€”â€”æ¯”å¦‚è¯†åˆ«ç›²é“æ–¹å‘ã€åˆ¤æ–­çº¢ç»¿ç¯çŠ¶æ€ï¼Œç”šè‡³é€šè¿‡è¯­éŸ³æŒ‡ä»¤å¸®ä½ å¯»æ‰¾â€œæ‰¾ä¸åˆ°çš„æ°´æ¯â€ã€‚ ğŸ—ï¸ ç³»ç»Ÿæ¶æ„ï¼šç«¯äº‘ååŒ ä¸ºäº†åœ¨ä¿è¯è½»é‡åŒ–çš„åŒæ—¶å®ç°å¤æ‚çš„è§†è§‰ç®—æ³•ï¼Œæˆ‘é‡‡ç”¨äº†åˆ†ä½“å¼æ¶æ„ï¼š\nä½©æˆ´ç«¯ (é‡‡é›†å±‚)ï¼šæè‡´è½»é‡ï¼Œè´Ÿè´£é‡‡é›†è§†å¬æ•°æ®ã€‚ æœåŠ¡ç«¯ (ç®—åŠ›å±‚)ï¼šç”±ä¸€å°é«˜æ€§èƒ½ PC (RTX 3060) æ‰¿æ‹…ï¼Œå¤„ç† YOLO åˆ†å‰²ä¸å¤§æ¨¡å‹æ¨ç†ã€‚ ğŸ› ï¸ ç¡¬ä»¶é€‰å‹ (Hardware) 1. ä½©æˆ´ç«¯ (Wearable) æ ¸å¿ƒä¸»æ§: ESP32-CAM ä½æˆæœ¬ WiFi è§†é¢‘ä¼ è¾“æ–¹æ¡ˆ è§†è§‰ä¼ æ„Ÿå™¨: OV2640 æ‘„åƒå¤´æ¨¡å— å§¿æ€ä¼ æ„Ÿ: MPU6050 IMU ç”¨äºå¤´éƒ¨å§¿æ€è§£ç®—ï¼Œè¾…åŠ© 3D ç©ºé—´å®šä½ éŸ³é¢‘äº¤äº’: I2S éº¦å…‹é£ + éª¨ä¼ å¯¼è€³æœº å®ç°å…¨åŒå·¥è¯­éŸ³é€šè¯ ä¾›ç”µ: 3.7V é”‚ç”µæ±  + å‡å‹æ¨¡å— 2. è®¡ç®—æœåŠ¡ç«¯ (Server) ç”±äºç®—æ³•æ¶‰åŠå›¾åƒåˆ†å‰²å’Œå¤šæ¨¡æ€å¤§æ¨¡å‹ï¼Œæ— æ³•åœ¨æ ‘è“æ´¾ä¸Šè¿è¡Œï¼Œå› æ­¤æ­å»ºäº†åŸºäº NVIDIA RTX 3060 (12GB) çš„æœ¬åœ°æ¨ç†æœåŠ¡å™¨ã€‚\nğŸ§  æ ¸å¿ƒç®—æ³•ä¸è½¯ä»¶æ ˆ (Tech Stack) æ·±åº¦å­¦ä¹ æ¨¡å‹ (Local \u0026amp; Cloud) ä¸ºäº†å®ç°â€œå…¨èƒ½â€è¾…åŠ©ï¼Œæˆ‘éƒ¨ç½²äº†ä¸€å¥—å¤æ‚çš„æ¨¡å‹æµæ°´çº¿ï¼š\nç¯å¢ƒæ„ŸçŸ¥ (Nav): ä½¿ç”¨ YOLO-Seg è¿›è¡Œç›²é“ä¸æ–‘é©¬çº¿çš„å®æ—¶åˆ†å‰²ï¼Œç»“åˆ TrafficLight Model è¯†åˆ«çº¢ç»¿ç¯ã€‚ ä¸‡ç‰©æ£€æµ‹ (Find): éƒ¨ç½² YOLO-World (Open Vocabulary Detection)ï¼Œå®ç°äº†å¯¹ä»»æ„ç‰©ä½“ï¼ˆå¦‚â€œè¯ç“¶â€ã€â€œé’¥åŒ™â€ï¼‰çš„å¼€æ”¾è¯æ±‡æ£€æµ‹ï¼Œæ— éœ€é¢„è®­ç»ƒç‰¹å®šç±»åˆ«ã€‚ äººæœºäº¤äº’ (HCI): ASR: é˜¿é‡Œäº‘ DashScope (Paraformer æ¨¡å‹) å®ç°è¯­éŸ³è½¬æ–‡å­—ã€‚ LLM: è°ƒç”¨ Qwen-Omni-Turbo (é€šä¹‰åƒé—®) å¤„ç†å¤šæ¨¡æ€ç†è§£ä¸ç”Ÿæˆè‡ªç„¶è¯­è¨€å›å¤ã€‚ æ‰‹åŠ¿: Google MediaPipe Hand ç”¨äºæ‰‹éƒ¨è¿½è¸ªï¼Œè¾…åŠ©æŠ“å–ç‰©ä½“ã€‚ è½¯ä»¶æ¶æ„ åç«¯æ¡†æ¶: Python FastAPI (å¤„ç† WebSocket é«˜é¢‘è§†é¢‘æµ)ã€‚ é€šä¿¡åè®®: WebSocket (ESP32 -\u0026gt; PC ä¼ è¾“ MJPEG æµä¸ PCM éŸ³é¢‘)ã€‚ ğŸ’¡ æ ¸å¿ƒåŠŸèƒ½å®ç° 1. ç›²é“å¯¼èˆªä¸é¿éšœ é€šè¿‡ YOLO-Seg åˆ†å‰²å‡ºç›²é“åŒºåŸŸï¼Œè®¡ç®—æ©è†œä¸­å¿ƒçº¿ã€‚å½“ç”¨æˆ·åç¦»ç›²é“æ—¶ï¼Œç³»ç»Ÿä¼šé€šè¿‡éª¨ä¼ å¯¼è€³æœºå‘å‡ºâ€œå‘å·¦åâ€ã€â€œç›´è¡Œâ€ç­‰æŒ‡ä»¤ ã€‚\n2. â€œå¸®æˆ‘æ‰¾ä¸œè¥¿â€ (Visual Grounding) ç”¨æˆ·å‘å‡ºè¯­éŸ³æŒ‡ä»¤ï¼šâ€œå¸®æˆ‘æ‰¾ä¸€ä¸‹æ¡Œä¸Šçš„çº¢ç‰›â€ã€‚\nç³»ç»Ÿè§£æè¯­éŸ³æ„å›¾ã€‚ è°ƒç”¨ YOLO-World æ£€æµ‹è§†é‡å†…çš„â€œçº¢ç‰›â€ç‰©ä½“ã€‚ ç»“åˆ MPU6050 å§¿æ€æ•°æ®ä¸æ‰‹åŠ¿è¯†åˆ«ï¼Œè¯­éŸ³å¼•å¯¼ç”¨æˆ·æ‰‹éƒ¨ç§»åŠ¨ï¼šâ€œå†å¾€å·¦ä¸€ç‚¹ï¼Œå°±åœ¨æ‰‹è¾¹â€ã€‚ 3. å…¨åŒå·¥è¯­éŸ³åŠ©æ‰‹ åŒºåˆ«äºä¼ ç»Ÿçš„â€œå”¤é†’è¯â€æ¨¡å¼ï¼Œç³»ç»Ÿæ”¯æŒå…¨åŒå·¥ (Full-Duplex) å¯¹è¯ï¼Œç”¨æˆ·å¯ä»¥éšæ—¶æ‰“æ–­ AI çš„æ’­æŠ¥ï¼Œäº¤æµæ›´åŠ è‡ªç„¶æµç•…ã€‚\nğŸ“¸ ç›‘æ§ä¸è°ƒè¯• å¼€å‘äº†ä¸€ä¸ª Web ç›‘æ§å°ï¼Œå¯ä»¥åœ¨æµè§ˆå™¨ä¸­å®æ—¶æŸ¥çœ‹ï¼š\nESP32 ä¼ å›çš„ç¬¬ä¸€è§†è§’ç”»é¢ YOLO å®æ—¶æ ‡æ³¨çš„æ£€æµ‹æ¡†ä¸åˆ†å‰²æ©è†œ è®¾å¤‡çš„ IMU å§¿æ€æ•°æ® åå°æ—¥å¿—ä¸â€œé»‘åŒ£å­â€å½•åƒ ğŸ“ éš¾ç‚¹æ”»å…‹ 1. CUDA ç¯å¢ƒé…ç½® ç”±äºä¾èµ– YOLO-World å’Œå„ç±»åˆ†å‰²æ¨¡å‹ï¼Œé…ç½® PyTorch çš„ GPU ç¯å¢ƒæå…¶å¤æ‚ã€‚éœ€è¦ç²¾ç¡®åŒ¹é… CUDA 11.8+ ä¸ Torch ç‰ˆæœ¬ï¼Œå¦åˆ™æ— æ³•è°ƒç”¨ RTX 3060 åŠ é€Ÿã€‚\n2. ESP32 éŸ³è§†é¢‘åŒæ­¥ ESP32 æ€§èƒ½æœ‰é™ï¼ŒåŒæ—¶å¼€å¯ WiFi è§†é¢‘æµ (MJPEG) å’ŒéŸ³é¢‘æµ (PCM) ææ˜“é€ æˆå¡é¡¿ã€‚æœ€ç»ˆé€šè¿‡ä¼˜åŒ– WebSocket å°åŒ…ç­–ç•¥å’Œé™ä½ JPEG è´¨é‡è§£å†³äº†é«˜å»¶è¿Ÿé—®é¢˜ã€‚\nè¿™æ˜¯ä¸€ä¸ªä»ç¡¬ä»¶ç„Šæ¥ã€åµŒå…¥å¼ç¼–ç¨‹åˆ°åç«¯ç®—æ³•éƒ¨ç½²çš„å…¨æ ˆé¡¹ç›®ã€‚å¦‚æœä½ å¯¹å…¶ä¸­çš„æŠ€æœ¯ç»†èŠ‚æ„Ÿå…´è¶£ï¼Œæ¬¢è¿æŸ¥çœ‹æˆ‘çš„ GitHub ä»“åº“ï¼\n","permalink":"https://wave-cb.github.io/projects/ai-glasses/","summary":"è¿™æ˜¯ä¸€ä¸ªé›†æˆäº†ç›²é“åˆ†å‰²ã€çº¢ç»¿ç¯è¯†åˆ«ä¸å¼€æ”¾è¯æ±‡ç‰©ä½“æ£€æµ‹çš„è¡ŒåŠ¨è¾…åŠ©ç³»ç»Ÿï¼Œé‡‡ç”¨ ESP32 é‡‡é›†è§†é¢‘æµï¼ŒRTX 3060 æœ¬åœ°ç®—åŠ›è¿›è¡Œå®æ—¶æ¨ç†ã€‚","title":"åŸºäº ESP32 ä¸ç«¯ä¾§ç®—åŠ›çš„AIè§†éšœçœ¼é•œ"},{"content":"hello world!\n","permalink":"https://wave-cb.github.io/posts/my-first-post/","summary":"\u003cp\u003ehello world!\u003c/p\u003e","title":"My First Post"}]